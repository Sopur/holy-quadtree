/**
 * @license GPL
 * @author Sopur (Someguy1834)
 * @description Optimized QuadTree made by Sopur
 * @about Inspired by https://github.com/timohausmann/quadtree-js because of how unbearably slow it was
 * @warn There is basically no error checking, so that's on you
 */
!function(t){class s{constructor(t,s=10,e=4,i=0){this.maxObjects=s,this.maxLevels=e,this.level=i,this.bounds=t,this.objects=[],this.objectReferences=[],this.nodes=[]}split(){const t=this.level+1,e=Math.round(this.bounds.width/2),i=Math.round(this.bounds.height/2),h=Math.round(this.bounds.x),n=Math.round(this.bounds.y);this.nodes[0]=new s({x:h+e,y:n,width:e,height:i},this.maxObjects,this.maxLevels,t),this.nodes[1]=new s({x:h,y:n,width:e,height:i},this.maxObjects,this.maxLevels,t),this.nodes[2]=new s({x:h,y:n+i,width:e,height:i},this.maxObjects,this.maxLevels,t),this.nodes[3]=new s({x:h+e,y:n+i,width:e,height:i},this.maxObjects,this.maxLevels,t)}getIndex(t){const s=this.bounds.x+this.bounds.width/2,e=this.bounds.y+this.bounds.height/2;let i=-1;return t.x<s&&t.x+t.width<s?t.y<e&&t.y+t.height<e?i=1:t.y>e&&(i=2):t.x>s&&(t.y<e&&t.y+t.height<e?i=0:t.y>e&&(i=3)),i}insert(t){if(void 0!==this.nodes[0]){const s=this.getIndex(t);if(-1!==s)return void this.nodes[s].insert(t)}if(this.objects.push(t),this.objects.length>this.maxObjects&&this.level<this.maxLevels){void 0===this.nodes[0]&&this.split();for(let t=0;t<this.objects.length;){const s=this.getIndex(this.objects[t]);-1!==s?this.nodes[s].insert(this.objects.splice(t,1)[0]):t++}}}retrieve(t){let s=this.objects;if(void 0!==this.nodes[0]){const e=this.getIndex(t);if(-1!==e){if(this.nodes[e].x>t.x+t.width||this.nodes[e].x<t.x-t.width||this.nodes[e].y>t.y+t.height||this.nodes[e].y<t.y-t.height)return[];s=s.concat(this.nodes[e].retrieve(t))}else for(let e=0;e<this.nodes.length;e++){if(this.nodes[e].x>t.x+t.width||this.nodes[e].x<t.x-t.width||this.nodes[e].y>t.y+t.height||this.nodes[e].y<t.y-t.height)return[];s=s.concat(this.nodes[e].retrieve(t))}}return s}getObjectNode(t){if(0===this.nodes.length)return this;const s=this.getIndex(t);return-1===s?this:this.nodes[s].getObjectNode(t)||!1}removeObject(t){let s=this.getObjectNode(t);const e=s.objects.indexOf(t);return-1!==e&&(s.objects.splice(e,1),!0)}clear(){if(this.objects=[],0!==this.nodes.length){for(let t=0;t<this.nodes.length;t++)this.nodes[t].clear();this.nodes=[]}}}window.HolyQuadTree={QuadTree:s,Bound:class{constructor(t,s){this.width=t,this.height=s,this.x=0,this.y=0}},Node:class{constructor(t,s,e,i,h){this.x=t,this.y=s,this.width=e,this.height=i,this.identifier=h}}}}();
